# Лабораторная работа 1 по Алгоритмам и Структурам Данных.

`TUser` - класс реализующий процесс:
- `Number` - порядковый номер процесса;
- `IsProccessActive` - хранит статус активности процесса (есть ли ещё активные запросы у процесса);
- `TPriorityLvl : Byte` описывающий уровень приоритета у процесса (__1__ - самый важный, __255__ - самый неважный);
- `TRequests - Array Of Request`, где `Request : Integer` кол-во запросов у процесса;
- `RequestPointer : Integer` - хранит порядковый номер следующего запроса у процессора;
- `IsProcessWork : Boolean` - хранит статус работы с процессором ( если `True` - процессор сейчас работает с процессом);
  - `ProcessWorkLength : Integer` - хранит количество условных единиц до завершения процесса; 
- `IsProcessWriting : Boolean` - хранит статус обдумывания процессора (если `True` - то процесс пишет, иначе процесс свободен); 
  - _*После завершения работ с последним процессом время на обдумывание не учитывается.*_
- `ProcessWritingLength: Integer` - хранит количество условных единиц до завершения обдумывания.
`TArrayOfUsers` - хранит список `TUser` который будет использоваться в реализации у `TQueueOfUsers`;
`TPriorityQueue<TUser>` - реализация приоритетной очереди через TUser.
- Реализация внутренней сортировки данных с учётом приоритета и порядкового номера процесса.
- _*Место добавления элемента в очередь определяется относительно приоритета процесса. Процессы с большим приоритетом добавляются в начало очереди и так далее...*_

`TCore` - ядро реализующая часть процессора принимающая запросы.
- `Users: TArrayOfUsers` - хранит все процессы
- `QueueOfUsers: TQueueOfUsers` очередь процессов
- `TickTime: Integer` - время такта ядра процессора
- `WaitTime: Integer` - время на обдумывание у ядра процессора

## Main Algorithm 
Описательная часть основного алгоритма программы:
1. Определиться с тем, относительно чего будет работать цикл: </br>
    - `While` есть процессы в очереди;
    - Проверка на то, есть ли в очереди процессы, производиться по завершение такта процессора.
    - __В средине такта брать процесс нельзя!__
2. Проверка на то, есть ли у текущего процесса запросы и свободен ли процесс сейчас:
    - Проверяем, `If` у процесса сейчас время на обдумывание `Then` процесс не в очереди:
      - Переменная `IsProcessWait := True` && `ProcessorWaitLength := X`, где `X` - кол-во условных единиц до завершения обдумывания.
    - `Else` проверяем, `If` процесс сейчас работает, то есть занят процессором, `Then`:
      - Переменная `IsProcessWork := True` && `ProcessorWorkLength := Y`, где `Y` - кол-во условных единиц до завершения работы с запросом.
    - `Else`:
      - `IsProcessWait := False && IsProcessWork := False && ProcessorWaitLength := 0 && ProcessorWorkLength := 0` => Процесс готов к работе с процессором, при условии, что `IsProcessActive == True`;
      - `RequestPointer++`.
3. Работа с взятым процессом: 
    - `IsProcessWork := True && ProcessorWorkLength` := _Время работы запроса из таблицы запросов_ => `Requests[RequestPointer]`; 
    - `If` `ProcessorWorkLength < 1` `Then`:
      - Процессор завершил обработку запроса;
      - Переменная хранящая время простоя += `Abs(ProcessorWorkLength)`;
      - `If` `RequestPointer == Length(Requests)` `Then`:
        - `IsProcessActive := False`;
        - Завершаем работы с текущим процессом.
      - `Else`:
        - `IsProcessWait := True`;
        - `ProcessorWaitLength := Core.WaitTime`.
4. Проверка, не занят ли процесс обдумыванием запроса:
   - `If` `ProcessorWaitLength < 1` `Then`:
     - `IsProcessWait := False`;
     - `ProcessorWaitLength := 0`;
     - Процесс готов работать, его можно добавлять в очередь.
   - `Else`:
     - `ProcessorWaitLength -= TickTime`;
     - Продолжаем работу по обдумыванию.